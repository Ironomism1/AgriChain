AGRICHAIN + AGRIPREDICT PLATFORM
Functioning and Workflow Overview

==============================================================================
1. SYSTEM ARCHITECTURE OVERVIEW
==============================================================================

The platform is a comprehensive agricultural technology ecosystem consisting of:

A) AGRIPREDICT MODULE
   - ML-powered predictive engine for crop planning and optimization
   - Runs on Flask backend with Python ML models
   - Helps farmers make data-driven decisions

B) AGRICHAIN MODULE
   - Blockchain-based marketplace connecting farmers and buyers
   - Real-time communication system
   - Smart contract management for secure transactions
   - Escrow payment system for buyer protection

C) UNIFIED BACKEND
   - Node.js/Express API server
   - MongoDB database for storing all data
   - Socket.IO for real-time messaging
   - JWT authentication for secure access

D) FRONTEND (REACT)
   - Modern responsive UI for both farmers and buyers
   - Real-time chat interface
   - Marketplace browsing and listing management
   - Wallet integration for blockchain


==============================================================================
2. USER ROLES & AUTHENTICATION WORKFLOW
==============================================================================

USER TYPES:
   ‚Ä¢ FARMER: Creates crop listings, receives buyer inquiries, executes contracts
   ‚Ä¢ BUYER: Browses listings, connects with farmers, negotiates contracts
   ‚Ä¢ ADMIN: Oversees all contracts, verifies compliance, manages disputes

AUTHENTICATION FLOW:
   1. User visits login page (/login)
   2. Enters email and password
   3. Backend validates credentials against MongoDB User collection
   4. Password verified using bcryptjs hashing
   5. JWT token generated and stored in localStorage
   6. Token includes: userId, role, email, name
   7. All subsequent API calls include token in Authorization header
   8. Token verified by JWT middleware on backend
   9. User redirected to role-specific dashboard


==============================================================================
3. AGRIPREDICT WORKFLOW (Planning Phase)
==============================================================================

STEP 1: CROP REGISTRATION
   Input: Farmer enters district and crop type
   Action: Registration stored in system
   Output: Confirmation and tracking enrollment

STEP 2: SOIL ANALYSIS & CROP RECOMMENDATION
   Input: Farmer enters soil parameters
      - Nitrogen (N) level (kg/hectare)
      - Phosphorus (P) level (kg/hectare)
      - Potassium (K) level (kg/hectare)
      - pH value
      - Temperature (¬∞C)
      - Humidity (%)
      - Rainfall (mm)
   Process: Decision Tree ML model analyzes soil profile
   Output: Top 3 recommended crops with suitability scores
   Use Case: Farmer selects best crop for their land conditions

STEP 3: DEMAND PREDICTION
   Input: Farmer selects a crop
   Process: Analytics engine checks historical demand + current registrations
   Output: Demand forecast (High/Medium/Low) with bar chart
           Number of other farmers growing same crop (saturation indicator)
   Use Case: Farmer assesses market competition and viability

STEP 4: YIELD & PRICE PREDICTION
   Input: District, Crop type, Planned cultivation area (acres)
   Process: Linear Regression models using district-level historical data
   Output: 
      - Expected yield in quintals/kg per acre
      - Market price prediction (per kg/quintal)
      - Total expected revenue
   Use Case: Farmer does financial planning and sets revenue targets

STEP 5: FERTILIZER RECOMMENDATION
   Input: Crop type, soil NPK values, temperature, humidity, moisture
   Process: Specialized ML model for nutrient optimization
   Output: Optimal fertilizer blend (NPK ratios) and application schedule
   Use Case: Farmer optimizes yields while minimizing fertilizer costs


==============================================================================
4. AGRICHAIN MARKETPLACE WORKFLOW (Listing Phase)
==============================================================================

STEP 1: CREATE LISTING
   Farmer inputs:
      - Crop type (informed by AgriPredict recommendation)
      - Variety/Grade
      - Quantity (informed by yield prediction)
      - Expected price (informed by price prediction)
      - Quality specifications (moisture %, defects allowed)
      - Location (district, latitude/longitude)
      - Contact information
      - Expected harvest date
      - Available for contract: Yes/No
   
   System stores in MongoDB Listing collection:
      - Status: "Active"
      - Created timestamp
      - Farmer reference (_id)
      - Images (if uploaded)
   
   Output: Listing published to marketplace, visible to all buyers

STEP 2: BUYER BROWSING & FILTERING
   Buyer actions:
      - Browse crop listings with filters:
         ‚Ä¢ Crop type
         ‚Ä¢ Price range
         ‚Ä¢ Quantity
         ‚Ä¢ Location/District
         ‚Ä¢ Quality grade
         ‚Ä¢ Harvest date
      - View farmer profile (reviews, previous contracts)
      - Compare multiple listings with price trends

STEP 3: BUYER INTEREST NOTIFICATION
   Buyer clicks "Interested" button on listing
   System:
      1. Creates notification record in MongoDB Notification collection
      2. Sends SMS to farmer via Twilio API with:
         - Buyer name and contact
         - Listing details
         - Request to contact buyer
      3. Shows notification on farmer's dashboard
      4. Farmer receives email alert


==============================================================================
5. REAL-TIME CHAT & COMMUNICATION WORKFLOW
==============================================================================

TECHNOLOGY STACK:
   - Socket.IO for real-time bidirectional communication
   - MongoDB Chat collection for message persistence
   - Backend Socket.IO server on port 8000
   - Frontend Socket.IO client on port 3000

CHAT INITIALIZATION:
   1. User logs in, currentUser set from localStorage
   2. Frontend establishes Socket.IO connection with JWT token
   3. Socket authenticated via JWT middleware
   4. User joins global room: socket.emit('join-user', userId)
   5. User receives list of previous conversations

START NEW CHAT:
   1. Buyer/Farmer clicks "‚ûï New Chat"
   2. Modal displays available users (all other users)
   3. User selects participant to chat with
   4. System creates new conversation in MongoDB Chat collection
   5. Initial message sent: "Hi, I'd like to connect with you"
   6. Socket.IO rooms created for real-time updates

SEND MESSAGE:
   1. User types message in input box
   2. Click "Send" button
   3. Message validated (not empty)
   4. Message sent to backend via POST /api/chat/send:
      - Content
      - ParticipantId (receiver)
      - SenderId (from currentUser)
      - SenderName
      - Timestamp
   5. Backend stores in MongoDB Chat collection
   6. Socket.IO broadcasts message to receiver via 'receive-chat-message' event
   7. Message appears instantly on receiver's screen
   8. Conversation list updated with last message preview

MARK IMPORTANT MESSAGE:
   1. User hovers over message and clicks üî¥ (mark important) button
   2. Frontend sends PUT request to backend
   3. Backend sets message.isImportant = true
   4. Socket.IO emits 'message-marked-important' event
   5. Message UI updates showing ‚ù§Ô∏è icon and "Important" badge
   6. Important messages stored separately for notifications

TYPING INDICATOR:
   1. User starts typing in message box
   2. Socket.IO emits 'typing' event: {conversationId, userName, isTyping: true}
   3. Backend broadcasts to other participants
   4. Receiver sees "[Name] is typing..." indicator
   5. When user stops typing (after 2 sec delay):
      Socket.IO emits 'typing' event: {isTyping: false}


==============================================================================
6. SMART CONTRACT & BLOCKCHAIN WORKFLOW
==============================================================================

CONTRACT CREATION:
   1. Farmer + Buyer negotiate terms in chat
   2. One party proposes contract with:
      - Price per unit (kg/quintal)
      - Quantity
      - Delivery window (start and end dates)
      - Quality standards (grade, moisture %, defects)
      - Payment terms:
         ‚Ä¢ Down payment % (e.g., 30% upfront)
         ‚Ä¢ Final payment schedule
         ‚Ä¢ Penalty for late delivery
   3. Contract template shown on UI
   4. Both parties review terms

BLOCKCHAIN SUBMISSION:
   1. Farmer clicks "Accept & Submit to Blockchain"
   2. Browser prompts: Connect MetaMask wallet
   3. User connects wallet (or Neo-compatible wallet)
   4. Contract hash calculated from terms
   5. Transaction prepared:
      - Smart Contract Address: 0x6471EACC40D24bC9F4BAB843560eDFEa190730c5
      - Network: Neo X Mainnet
      - Gas Token: GAS
      - Function: submitContract(farmerAddress, buyerAddress, terms, hash)
   6. User approves transaction in wallet
   7. Contract submitted on-chain (immutable record)
   8. Contract stored in MongoDB with:
      - Blockchain transaction hash
      - Timestamp
      - Status: "Active"

CONTRACT LIFECYCLE:
   Status Transitions:
      Proposed ‚Üí Accepted ‚Üí Active ‚Üí In Progress ‚Üí Completed
      
   Active: Both parties have signed, contract enforced
   In Progress: Delivery initiated, quality checking phase
   Completed: Delivery received, payment released
   
   Dispute Handling:
      - If quality issues detected ‚Üí Admin reviews
      - Buyer can dispute payment release
      - Admin can freeze escrow and investigate
      - Resolution recorded on blockchain


==============================================================================
7. PAYMENT & ESCROW WORKFLOW
==============================================================================

ESCROW SYSTEM:
   1. Contract specifies down payment (e.g., 30% of total)
   2. Buyer initiates payment via Razorpay payment gateway
   3. Payment captured and held in escrow (not transferred to farmer yet)
   4. Farmer receives notification: "Payment received, preparing shipment"

DELIVERY & VERIFICATION:
   1. Farmer prepares crop for delivery
   2. Quality inspector verifies crop meets contract specs:
      - Grade matches specified grade
      - Moisture content within limits
      - No defects beyond allowed percentage
   3. Inspector marks as "Approved" or "Rejected"

FINAL PAYMENT RELEASE:
   If approved:
      1. System releases escrow to farmer's account
      2. Final payment (70% balance) due if terms allow
      3. Buyer makes final payment via Razorpay
      4. Both parties marked as completed
   
   If rejected:
      1. Buyer can request refund
      2. Admin reviews dispute
      3. Escrow returned to buyer or renegotiation initiated

TRANSACTION RECORD:
   - All transactions stored in MongoDB EscrowTransaction collection
   - Blockchain hash stored for transparency
   - Payment status tracked: Pending ‚Üí Paid ‚Üí Released ‚Üí Completed


==============================================================================
8. DATA MODELS & DATABASE STRUCTURE
==============================================================================

USER COLLECTION:
   {
      _id: ObjectId
      name: String
      email: String (unique)
      password: String (bcrypt hashed)
      phone: String
      role: String (farmer/buyer/admin)
      profileImage: String (URL)
      location: {district, state, coordinates}
      bio: String
      rating: Number
      reviews: [String] (review _ids)
      createdAt: Date
      updatedAt: Date
   }

LISTING COLLECTION:
   {
      _id: ObjectId
      farmerId: ObjectId (reference to User)
      cropType: String
      variety: String
      quantity: Number (kg)
      price: Number (per unit)
      quality: {grade, moisture, defects}
      location: {district, coordinates}
      images: [String] (URLs)
      harvestDate: Date
      availableForContract: Boolean
      status: String (Active/Sold/Cancelled)
      createdAt: Date
   }

CHAT COLLECTION:
   {
      _id: ObjectId
      participants: [UserId, UserId]
      participantNames: [String, String]
      messages: [
         {
            senderId: ObjectId
            senderName: String
            content: String
            timestamp: Date
            isImportant: Boolean
            isPinned: Boolean
         }
      ]
      lastMessage: String
      lastMessageTime: Date
      unreadCount: {UserId: Number, UserId: Number}
      createdAt: Date
   }

CONTRACT COLLECTION:
   {
      _id: ObjectId
      farmerId: ObjectId
      buyerId: ObjectId
      listingId: ObjectId
      terms: {
         price: Number
         quantity: Number
         deliveryStart: Date
         deliveryEnd: Date
         qualitySpecs: Object
         paymentTerms: Object
      }
      blockchainHash: String
      transactionHash: String
      status: String (Proposed/Accepted/Active/In Progress/Completed/Disputed)
      createdAt: Date
      lastUpdated: Date
   }

ESCROW TRANSACTION COLLECTION:
   {
      _id: ObjectId
      contractId: ObjectId
      amount: Number
      currency: String
      status: String (Held/Released/Refunded)
      paymentGateway: String (Razorpay)
      transactionId: String (from Razorpay)
      blockchainHash: String
      createdAt: Date
   }

NOTIFICATION COLLECTION:
   {
      _id: ObjectId
      userId: ObjectId (recipient)
      type: String (BuyerInterest/MessageReceived/PaymentReceived/ContractCreated)
      relatedId: ObjectId (listing/message/contract)
      message: String
      read: Boolean
      createdAt: Date
   }


==============================================================================
9. API ENDPOINTS SUMMARY
==============================================================================

AUTHENTICATION ENDPOINTS:
   POST /api/auth/register          - Create new user account
   POST /api/auth/login             - User login (returns JWT token)
   GET /api/auth/profile            - Get current user profile
   POST /api/auth/logout            - Clear session
   GET /api/auth/all-users          - Get list of available users for chat

LISTING ENDPOINTS:
   POST /api/listings               - Create new crop listing
   GET /api/listings                - Browse listings with filters
   GET /api/listings/:id            - View specific listing
   PUT /api/listings/:id            - Update listing
   DELETE /api/listings/:id         - Remove listing

CHAT ENDPOINTS:
   GET /api/chat/conversations      - Fetch user's conversation list
   GET /api/chat/:conversationId    - Get all messages in conversation
   POST /api/chat/send              - Send new message
   PUT /api/chat/:conversationId/:messageId/important - Mark message important
   GET /api/chat/important/all      - Get all important messages

CONTRACT ENDPOINTS:
   POST /api/contracts              - Create new contract
   GET /api/contracts               - List user's contracts
   GET /api/contracts/:id           - View contract details
   PUT /api/contracts/:id           - Update contract status
   POST /api/contracts/:id/sign     - Submit to blockchain

PAYMENT ENDPOINTS:
   POST /api/payments/create        - Initialize Razorpay payment
   POST /api/payments/verify        - Verify payment completion
   GET /api/escrow/:transactionId   - Check escrow status

NOTIFICATION ENDPOINTS:
   GET /api/notifications           - Get user's notifications
   PUT /api/notifications/:id/read  - Mark notification as read


==============================================================================
10. REAL-TIME FEATURES (SOCKET.IO EVENTS)
==============================================================================

CLIENT TO SERVER EVENTS:
   'join-user'                      - Register user as online
   'send-chat-message'              - Send message to another user
   'join-chat'                      - Join conversation room
   'typing'                         - Notify others user is typing
   'mark-message-important'         - Mark message as important
   'disconnect'                     - User going offline

SERVER TO CLIENT EVENTS:
   'receive-chat-message'           - New message received
   'user-typing-status'             - Typing indicator status
   'message-marked-important'       - Important marker update
   'important-message-notification' - Important message alert
   'user-joined-chat'               - User joined conversation
   'user-left-chat'                 - User left conversation


==============================================================================
11. KEY FEATURES & DIFFERENTIATORS
==============================================================================

1. DATA-DRIVEN DECISION MAKING
   - AgriPredict ML models guide crop selection
   - Price predictions enable fair pricing
   - Yield forecasts help financial planning
   - Reduces farmer risk through evidence-based recommendations

2. SECURE BLOCKCHAIN INTEGRATION
   - Immutable contract records on Neo X Mainnet
   - Cryptographic proof of agreement
   - Transparent dispute resolution
   - Builds trust between farmers and buyers

3. REAL-TIME COMMUNICATION
   - Socket.IO messaging for instant farmer-buyer connection
   - Important message marking for critical negotiations
   - Typing indicators and read receipts
   - Reduces communication delays

4. ESCROW PAYMENT PROTECTION
   - Razorpay integration for secure payments
   - Funds held until quality verification
   - Automatic release on contract completion
   - Dispute resolution mechanism

5. ROLE-BASED ACCESS CONTROL
   - Farmers see listings and buyer inquiries
   - Buyers browse and filter listings
   - Admin oversees contracts and disputes
   - Each role has specialized dashboard

6. NOTIFICATION SYSTEM
   - SMS alerts via Twilio for urgent events
   - In-app notifications for all activities
   - Email digests of recent activities
   - Configurable notification preferences

7. RATING & REPUTATION
   - Users build reputation through successful contracts
   - Reviews posted by counterparties
   - Rating visible on profile
   - Incentivizes honest dealings


==============================================================================
12. WORKFLOW SUMMARY: FARMER PERSPECTIVE
==============================================================================

DAY 1: PLANNING (AgriPredict)
   ‚Üí Use crop recommendation to select best crop for soil
   ‚Üí Check demand forecast for market viability
   ‚Üí Get yield and price prediction
   ‚Üí Make decision: "I'll grow Paddy on 2 acres"

DAY 2-3: MARKETPLACE (AgriChain)
   ‚Üí Create listing with crop details from prediction
   ‚Üí Set price based on market prediction
   ‚Üí Specify quality standards
   ‚Üí Publish listing on marketplace

DAY 4-10: WAITING & NEGOTIATION
   ‚Üí Receive buyer interest notifications via SMS
   ‚Üí Start chat with interested buyer
   ‚Üí Negotiate price and terms in real-time chat
   ‚Üí Mark important messages for reference

DAY 11-15: CONTRACT EXECUTION
   ‚Üí Agree on final terms
   ‚Üí Submit contract to blockchain
   ‚Üí Receive down payment (30%) in escrow
   ‚Üí Farmer receives notification of payment held

DAY 16-30: CULTIVATION & DELIVERY
   ‚Üí Cultivate crop as planned
   ‚Üí Prepare for harvest and quality inspection
   ‚Üí Quality inspector verifies crop meets specs
   ‚Üí Arrange transportation to delivery point

DAY 31: SETTLEMENT
   ‚Üí Delivery completed and verified
   ‚Üí Escrow released to farmer account
   ‚Üí Buyer pays final 70% balance
   ‚Üí Both parties leave reviews
   ‚Üí Contract marked "Completed" on blockchain


==============================================================================
13. WORKFLOW SUMMARY: BUYER PERSPECTIVE
==============================================================================

STEP 1: DISCOVERY
   ‚Üí Browse AgriChain marketplace
   ‚Üí Filter by crop type, price, location
   ‚Üí Review AgriPredict price trends
   ‚Üí Compare farmer ratings and reviews

STEP 2: EVALUATION
   ‚Üí Click on specific listing
   ‚Üí View farmer profile and past contracts
   ‚Üí Check quality specifications
   ‚Üí Compare with other similar listings

STEP 3: INTEREST
   ‚Üí Click "Interested" button
   ‚Üí Farmer receives SMS notification
   ‚Üí Wait for farmer to initiate contact

STEP 4: NEGOTIATION
   ‚Üí Join real-time chat with farmer
   ‚Üí Discuss price adjustments (small variations okay)
   ‚Üí Agree on delivery schedule and quality standards
   ‚Üí Mark important terms for reference

STEP 5: AGREEMENT
   ‚Üí Finalize contract terms
   ‚Üí Review contract preview
   ‚Üí Approve and submit to blockchain
   ‚Üí Down payment (30%) made via Razorpay

STEP 6: RECEIPT & VERIFICATION
   ‚Üí Receive quality inspection report
   ‚Üí Verify crop meets specified standards
   ‚Üí If approved: Release payment or confirm final payment
   ‚Üí If rejected: Request refund or renegotiation

STEP 7: COMPLETION
   ‚Üí Mark contract as received
   ‚Üí Leave review for farmer
   ‚Üí Transaction recorded on blockchain
   ‚Üí Both parties build reputation


==============================================================================
14. ADMIN OVERSIGHT FEATURES
==============================================================================

ADMIN DASHBOARD:
   - All contracts across platform
   - User management (activate/deactivate/verify)
   - Dispute resolution queue
   - Contract lifecycle monitoring
   - Analytics: Transaction volume, farmer ratings, payment success rate

DISPUTE RESOLUTION:
   1. Admin receives dispute notification
   2. Reviews contract terms and blockchain record
   3. Checks quality inspection report
   4. Reviews chat history between parties
   5. Decides: Full refund, partial refund, payment release, or renegotiation
   6. Implements decision in system
   7. Notifies both parties of resolution

COMPLIANCE MONITORING:
   - Verify farmers are genuine agricultural producers
   - Check buyer credentials
   - Monitor for fraudulent listings
   - Ensure payment compliance
   - Track contract completion rates


==============================================================================
15. TECHNOLOGY STACK SUMMARY
==============================================================================

FRONTEND (React):
   - React 17+
   - React Router for navigation
   - Context API for state management
   - Axios for API calls
   - Socket.IO client for real-time updates
   - Bootstrap 5 for UI components
   - GSAP for animations
   - MetaMask integration for wallet

BACKEND (Node.js):
   - Express.js for REST API
   - Socket.IO for real-time messaging
   - Mongoose for MongoDB ODM
   - JWT for authentication
   - bcryptjs for password hashing
   - Multer for file uploads
   - Twilio SDK for SMS notifications
   - Razorpay SDK for payments
   - Web3.js for blockchain interaction

DATABASE (MongoDB):
   - User collection
   - Listing collection
   - Chat collection
   - Contract collection
   - EscrowTransaction collection
   - Notification collection
   - Review collection
   - And others for analytics

BLOCKCHAIN:
   - Smart contract: Report.sol (Solidity)
   - Network: Neo X Mainnet
   - Contract Address: 0x6471EACC40D24bC9F4BAB843560eDFEa190730c5
   - Wallet: MetaMask or Neo-compatible

EXTERNAL SERVICES:
   - Twilio: SMS notifications
   - Razorpay: Payment processing
   - Neo X: Blockchain network
   - Cloudinary: Image storage (optional)

ML ENGINE (AgriPredict - Python):
   - Flask web framework
   - scikit-learn for ML models
   - Pandas, NumPy for data processing
   - Matplotlib for visualization
   - Historical dataset: 8+ districts


==============================================================================
16. SECURITY MEASURES
==============================================================================

AUTHENTICATION & AUTHORIZATION:
   ‚úì JWT tokens with expiration
   ‚úì Password hashing with bcryptjs
   ‚úì Role-based access control (RBAC)
   ‚úì Protected API routes with middleware

DATA PROTECTION:
   ‚úì MongoDB collection-level access controls
   ‚úì User data encrypted in transit (HTTPS)
   ‚úì Sensitive data not logged
   ‚úì Environment variables for secrets

BLOCKCHAIN SECURITY:
   ‚úì Smart contract audited before deployment
   ‚úì Immutable contract records
   ‚úì Cryptographic signatures
   ‚úì Multi-signature verification for disputes

PAYMENT SECURITY:
   ‚úì Razorpay PCI-DSS compliant
   ‚úì No credit card data stored on servers
   ‚úì Escrow holds funds securely
   ‚úì Transaction verification required

SOCKET.IO SECURITY:
   ‚úì JWT authentication required for connection
   ‚úì User validation before message delivery
   ‚úì Rate limiting to prevent spam
   ‚úì Message encryption for sensitive data


==============================================================================
17. PERFORMANCE OPTIMIZATIONS
==============================================================================

FRONTEND:
   - Code splitting for faster page loads
   - Lazy loading for images and components
   - Caching of API responses
   - Socket.IO connection pooling

BACKEND:
   - Database indexing on frequently queried fields
   - Pagination for large data sets
   - Redis caching (optional enhancement)
   - Connection pooling for MongoDB

MESSAGING:
   - Socket.IO room-based broadcasting (vs individual messages)
   - Message compression for bandwidth savings
   - Batch updates to reduce DB writes

BLOCKCHAIN:
   - Batch contract submissions to reduce gas costs
   - Off-chain storage for metadata, on-chain for proof


==============================================================================
18. DEPLOYMENT CONFIGURATION
==============================================================================

FRONTEND:
   - Deployed on port 3000 (development) / port 80 (production)
   - Environment: Node.js runtime
   - Build: npm run build ‚Üí production bundle

BACKEND:
   - Deployed on port 8000
   - Environment: Node.js runtime
   - Database: MongoDB connection string from .env

BLOCKCHAIN:
   - Smart contract deployed on Neo X Mainnet
   - Verified on blockchain explorer
   - Contract address known to frontend

DATABASE:
   - MongoDB cluster (local or cloud)
   - Collections indexed for performance
   - Backup strategy implemented

ML ENGINE:
   - Deployed on separate port (default 5000)
   - Flask development or production WSGI server
   - Model files stored locally

NOTIFICATIONS:
   - Twilio account configured with API keys
   - Razorpay account configured with API keys


==============================================================================
19. FUTURE ENHANCEMENTS
==============================================================================

PHASE 2 FEATURES:
   ‚úì Mobile app (React Native)
   ‚úì Video calls for farmer-buyer meetings
   ‚úì Quality verification via AI image analysis
   ‚úì Advanced analytics dashboard
   ‚úì Predictive inventory management

SCALABILITY:
   ‚úì Load balancing for multiple API servers
   ‚úì Microservices architecture
   ‚úì Message queue (RabbitMQ/Kafka) for async tasks
   ‚úì GraphQL API option

COMPLIANCE:
   ‚úì Multi-language support
   ‚úì Regulatory compliance (GDPR, local laws)
   ‚úì Accessibility compliance (WCAG)

ECOSYSTEM:
   ‚úì Integration with government agriculture schemes
   ‚úì Insurance partnerships
   ‚úì Logistics provider integration
   ‚úì Credit/financing options for farmers


==============================================================================
20. TROUBLESHOOTING & SUPPORT
==============================================================================

COMMON ISSUES & SOLUTIONS:

Chat not loading:
   - Check JWT token in localStorage
   - Verify backend Socket.IO is running on 8000
   - Check browser console for errors
   - Clear browser cache and reload

Messages not sending:
   - Verify internet connection
   - Check that currentUser is loaded (check console)
   - Ensure both participants have active sessions
   - Restart Socket.IO connection

Contract not submitting:
   - Connect MetaMask wallet properly
   - Ensure sufficient GAS tokens for transaction
   - Check network is set to Neo X Mainnet
   - Verify contract terms are complete

Payment issues:
   - Check Razorpay account is active
   - Verify API keys in .env file
   - Ensure payment amount is valid
   - Check buyer's payment method is working

Database connection errors:
   - Verify MongoDB is running
   - Check connection string in .env
   - Ensure username/password are correct
   - Check firewall isn't blocking access

ML Model predictions incorrect:
   - Verify model files exist in models/ directory
   - Check input data format matches training data
   - Retrain models with latest agricultural data
   - Verify Flask server is running


==============================================================================
END OF DOCUMENT
==============================================================================

Generated: November 21, 2025
Platform: AgriChain + AgriPredict Integrated Agricultural System
